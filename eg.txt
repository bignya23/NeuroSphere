i have a backend root folder for backend in Django and inside that there is backend and auth_chat with login and signup which sign users with following data and the code is  # auth_chat/models.py from django.db import models from django.contrib.auth.models import AbstractUser from django.utils.translation import gettext_lazy as _  class User(AbstractUser):     username = models.CharField(         max_length=150,         unique=False  # Make username non-unique     )     name = models.CharField(max_length=255)     age = models.IntegerField(null=True, blank=True)     email = models.EmailField(_('email address'), unique=True)  # Keep email unique     parents_email = models.EmailField(null=True, blank=True)     phone_number = models.CharField(max_length=15)     disease = models.CharField(max_length=50, null=True, blank=True)     disease_level = models.CharField(max_length=20, null=True, blank=True)          USERNAME_FIELD = 'email'     REQUIRED_FIELDS = ['name']  # Remove username from required fields      def __str__(self):         return self.email      class Meta:         unique_together = []  # Remove any unique_together constraints                     # auth_chat/serializers.py    from rest_framework import serializers from .models import User from django.contrib.auth.hashers import make_password  class UserSerializer(serializers.ModelSerializer):     class Meta:         model = User         fields = ('id', 'name', 'age', 'email', 'parents_email', 'phone_number',                  'disease', 'disease_level', 'password', 'username')         extra_kwargs = {             'password': {'write_only': True},             'username': {'required': False},             'email': {'required': True}         }       def validate_email(self, value):         # Custom email validation to ensure uniqueness         if User.objects.filter(email=value).exists():             raise serializers.ValidationError("A user with this email already exists.")         return value      def create(self, validated_data):         # Generate username from email if not provided         if 'username' not in validated_data:             email = validated_data.get('email', '')             validated_data['username'] = email.split('@')[0]  # Use part before @ as username          # Handle optional fields with defaults         validated_data['parents_email'] = validated_data.get('parents_email', '')         validated_data['disease'] = validated_data.get('disease', '')         validated_data['disease_level'] = validated_data.get('disease_level', '')          # Hash the password         validated_data['password'] = make_password(validated_data.get('password'))          # Create user instance         user = User.objects.create(             username=validated_data['username'],             email=validated_data['email'],             name=validated_data.get('name', ''),             age=validated_data.get('age'),             parents_email=validated_data.get('parents_email', ''),             phone_number=validated_data.get('phone_number', ''),             disease=validated_data.get('disease', ''),             disease_level=validated_data.get('disease_level', ''),             password=validated_data['password']         )         return user from rest_framework import status from rest_framework.decorators import api_view, permission_classes from rest_framework.response import Response from rest_framework_simplejwt.tokens import RefreshToken from django.contrib.auth import get_user_model from .serializers import UserSerializer from rest_framework.permissions import AllowAny from django.core.exceptions import ObjectDoesNotExist  User = get_user_model()  @api_view(['POST']) @permission_classes([AllowAny]) def signup(request):     # Ensure that both email and password are provided     email = request.data.get('email')     password = request.data.get('password')      if not email or not password:         return Response({             'error': 'Email and password are required'         }, status=status.HTTP_400_BAD_REQUEST)      serializer = UserSerializer(data=request.data)          if serializer.is_valid():         try:             # Save the user and create refresh tokens             user = serializer.save()             refresh = RefreshToken.for_user(user)              return Response({                 'refresh': str(refresh),                 'access': str(refresh.access_token),                 'user': UserSerializer(user).data             }, status=status.HTTP_201_CREATED)          except Exception as e:             return Response({                 'error': 'Error creating user',                 'details': str(e)             }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)          return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)   @api_view(['POST']) @permission_classes([AllowAny]) def login(request):     email = request.data.get('email')     password = request.data.get('password')      if not email or not password:         return Response({             'error': 'Please provide both email and password'         }, status=status.HTTP_400_BAD_REQUEST)      try:         # Fetch user using email and check password         user = User.objects.get(email=email)          if user.check_password(password):  # This checks the password securely             # Create refresh and access tokens             refresh = RefreshToken.for_user(user)              return Response({                 'refresh': str(refresh),                 'access': str(refresh.access_token),                 'user': UserSerializer(user).data,                 'message': 'Login successful'             }, status=status.HTTP_200_OK)         else:             return Response({                 'error': 'Invalid credentials'             }, status=status.HTTP_401_UNAUTHORIZED)      except User.DoesNotExist:         return Response({             'error': 'No account found with this email'         }, status=status.HTTP_404_NOT_FOUND)     except Exception as e:         print(f"Login error: {str(e)}")  # For debugging         return Response({             'error': 'An error occurred during login'         }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)   now i want to make another app inside root backend named chatroom and i have react project for frontend  now make me react Chat.jsx component to use the chatroom and backend should be like ...when a user with Autism login and send message in chatroom ..the message will be seen to all the person with autism only not others ..it will be a chat room so write me the code for the task i said above and also give proper folder structure and and use websocket and make it totally functioning  